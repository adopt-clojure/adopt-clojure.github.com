{"version":3,"sources":["adopt_clojure/components/examples.cljs"],"mappings":";AAEA,6CAAA,7CAAMA;AAAN,AAAA,0FAAA,2DAAA,2CAAA,wDAAA,AAAA;;AAGA","names":["adopt-clojure.components.examples/examples"],"sourcesContent":["(ns adopt-clojure.components.examples)\n\n(defn examples []\n  [:section {:class 'examples}])\n\n(comment \n\n; Create simple pipelines of data to clearly express any transformation.\nuser=> (->> [1 2 3 4 5]\n            (map inc)\n            (filter even?)\n            (apply +))\n12\n\n; Write multi-threaded code with thread-safe wrappers so values are always synchronized.\nuser=> (def x (atom 0))\nuser=> (repeatedly 10\n        (fn [] (future (swap! x inc))))\nuser=> @x\n10 \n\n; Define simple macros to gain access to a whole new layer of abstraction.\nuser=> (defmacro unless [condition & body]\n         (list 'if condition \n               (cons 'do body)))\nuser=> (unless false (println \"false!\"))\nfalse!\n  \n)\n"]}